 ### Android面试知识点汇总

一、 基础

- [x] Android四大组件

    Android四大基本组件分别是Activity、Service服务、Content Provider内容提供者和BroadcastReciever广播接收器。

- [x] Activity的生命周期

    ```flow
    st=>start:Activity启动
    e=>end:Activity销毁
    onCreate=>operation:onCreate
    onStart=>operation:onStart
    onRestart=>operation:onRestart
    onResume=>operation:onResume
    onPause=>operation:onPause
    onStop=>operation:onStop
    onDestroy=>operation:onDestroy

    st->onCreate->onStart->onResume->onPause->onStop->onDestroy->e
    onStop->onRestart->onStart
    onPause->onResume

    ```

    1. onStart和onStop、onResume和onPause的区别？

        onStart和onStop表示Activity的可见状态，而onResume和onStop表示Activity是否是前台可交互的状态；

    2. A启动B，A的onPause和B的onResume哪个先执行？

        在新的Activity启动之前，栈顶的Activity要先onPause后，新的Activity才能启动。也就是A执行完onPause后再执行B的onCreate、onStart和onResume。所以这里注意不要在onPause中执行耗时的操作，影响界面切换速度。
    
    3. 异常生命周期调用——onSaveInstanceState和onRestoreInstanceState

        只有异常情况下才会调用这两个周期方法。onSaveInstanceState调用时机在onStop之前，与onPause没有时序关系。onRestoreInstanceState调用时机在onStart之后。

    4. Activity的生存优先级

        前台Activity正在交互，优先级最高；可见但非前台Activity，次之；后台Activity，不可见，优先级最低。


- [x] Activity的LaunchMode

    Activity的四种LaunchMode：    
    * standard   标准模式
    * singleTop  栈顶复用模式
    * singleTask   栈内复用模式具有cleanTop的效果 
    * singleInstance    加强型的singleTask，单例Activity只单独存在在一个任务栈中

    startActivityForResult的方式启动SingleTask或SingleInstance启动模式的Activity，onActivityResult会立即调用并返回REQUEST_CANCELED。

- [x] Intent和PendingIntent的区别

    a. Intent是立即使用，而PendingIntent有执行条件，还可以被cancel掉；
    b. Intent在程序结束后会终止，而PendingIntent不会，等待它自己的执行条件满足时候开始执行；
    c. PendingIntent自带Context，而Intent需要在某个Context内运行；
    d. Intent在原Task中运行，PendingIntent在新的Task中运行；

- [x] ContentProvider

    ContentProvider叫做内容提供者将特定的应用程序数据提供给其他的应用程序使用，数据可以是存储于文件系统、SQLite数据库或者其他方式。常见系统提供的ContentProvider有媒体、联系人、短信等。

    关键方法：
    ```
    //创建ContentProvider时候的调用
    public boolean onCreate();
    //查询
    public Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder);
    //插入数据到指定的Uri
    public Uri insert(Uri uri,ContentValues values);
    //从指定的Uri中删除数据
    public int delete(Uri uri,String selection,String[] selectionArgs);
    //更新Uri的Content Provider中的数据
    public int update(Uri uri,ContentValues values,String selection,String[] selectionArgs);
    //回去MIME数据类型
    public String getType(Uri uri);//vnd.android.cursor.dir/person——表示返回数据为person的集合。
    ```
    对ContentProvider的数据进行数据增删改查的时候，可以使用ContentResolver来完成。

    Uri,系统资源的唯一标识。

    `content://com.example.transportationprovider/trains/122`

    `content://`——标准前缀
    `com.example.transportationprovider`——Uri的标识，用于唯一标识这个ContentProvider，外部调用者可以用这个标识来找到这个Provider。
    `trains`——路径（Path），一般就是数据库中要操作的表的名称。
    `122`——数据ID。

    监听ContentProvider中的数据变化
    ```
    //注册回调
    getContentResolver().registerContentObserver(uri,new DataObserver());
    //notifyChange
    getContext().getContentResolver().notifyChange(uri,null);
    //onChange
    public class DataObserver extends ContentObserver {
        public void onChange(boolean selfChange) {
            //handle数据改变
        }
    }
    ```

- [x] BroadCastReceiver

    动态注册广播
    最好在Activity的onResume()注册、onPause()注销，因为异常退出的Activity可能会不执行onStop、onDestroy，造成内存泄露。
    广播也不能重复注册、重复注销。

    广播的类型主要分为5类：
    * 普通广播(Normal Broadcast)
        sendBroadcast(Intent);
    * 系统广播(System Broadcast)
    * 有序广播(Ordered Broadcast)
        有序针对广播的接收者而言的，发送出去的广播被接受者按照先后顺序接收。

        顺序规则：
        1. 按照Priority属性值从大到小排序；
        2. Priority属性相同的，动态注册广播优先;

        特点：
        1. 顺序接收
        2. 先接收的接收者可以对广播进行截断，后接收的广播接收者不再接收此广播；
        3. 先接收的接收者可以堆广播进行修改，后接收的广播接收者接收到的是被修改后的广播；

        sendOrderedBroadcast(Intent)

    * 粘性广播(Sticky Broadcast)
    * App应用内广播(Local Broadcast)

    前台广播和后台广播：flag——`Intent.FLAG_RECEIVER_FOREGROUND`

    面对两种问题：
    1. 其他应用针对性发出与当前应用IntentFilter匹配的广播，导致应用不断接收广播并处理；
    2. 其他应用注册与当前应用一致的IntentFilter用于接收广播，获取广播具体信息，造成安全性和效率性问题；

    解决方案：
    a. 将全局广播设置为局部广播
        * exported=false
        * 增设权限permission
        * 发送广播时设定接收者的所在的包名
            ```
            intent.setPackage(pkgName);
            ```
    b. 使用封装号的LocalBroadcastManager类
        
    **注意**

        对于不同注册方式的广播接收器回调onReceive(Context context,Intent intent)中Context返回值是不一样的：
        * 静态注册（全局或应用内广播），Context为ReceiverRestrictedContxt；
        * 全局广播的动态注册，Activity的Context；
        * 应用内动态注册（LocalBroadcastManager），Application的Context；
        * 应用内动态注册（非LocalBroadcastManager），Activity的Context；

- [x] Service

    Service称作后台服务，可以脱离UI来处理事务。Service运行与进程的主线程中，如果是UI进程的话，要注意耗时的操作会影响UI绘制，造成Anr。
    启动Service的方式：
    * startService
    * bindService

    销毁Service：
    * 仅startService启动的，stopService即可；
    * 仅bindService启动的，unbindService即可；
    * startService后，又bindService，需要stopService和unbindService后，才会销毁；    

- [x] IntentService

    IntentService Service和Handler的结合产物，IntentService持有一个HandlerThread，每次启动IntentService就会调用onStart，在onStart中提交一个Message到Handler中，去执行onHandleIntent。

- [x] Fragment的生命周期

    ```flow
    st=>start:Fragment is added
    e=>end:Fragment is destroyed
    onAttach=>operation:onAttach
    onCreate=>operation:onCreate
    onCreateView=>operation:onCreateView
    onActivityCreated=>operation:onActivityCreated
    onStart=>operation:onStart
    onResume=>operation:onResume
    onPause=>operation:onPause
    onStop=>operation:onStop
    onDestroyView=>operation:onDestroyView
    onDetach=>operation:onDetach
    st->onAttach->onCreate->onCreateView->onActivityCreated->onStart->onResume->onPause->onStop->onDestroyView->onDetach->e
    onDestroyView->onCreateView
    ```

- [x] Android系统的启动流程

    1. init进程

        * 电源启动
        * 引导程序Bootloader
        * linux内核启动
        * init进程启动

        init的入口函数在源码`system/core/init/init.cpp`
        其中`property_init`来对属性初始化，然后在`start_property_service`处启动属性服务，最后在`parser.ParseConfig("/init.rc")`来解析`init.rc`。

        `init.rc`中存有启动`zygote`启动参数与配置信息，解析到这些代码时，会fork出一个新的进程就是zygote。
        
    2. Zygote进程

        init启动Zygote主要调用`frameworks/base/cmds/app_process/app_main.cpp`的main函数中的AppRuntime的start来启动Zygote进程。AppRuntime继承于AndroidRuntime（`frameworks/base/core/jni/AndroidRuntime.cpp`），所以调用start函数也就是调用的AndroidRuntime的start。

        * 创建DVM
        * 为DVM注册JNI
        * 找到`com.android.internal.os.ZygoteInit`的main函数（`frameworks/base/core/java/com/android/internal/os/ZygoteInit.java`）
        * JNI调用Java的main函数，执行Java框架层初始化
        * `registerZygoteSocket`创建一个Server端的Socket，等待ActivityManagerService请求创建新应用的进程
        * `preload`预加载类和资源
        * `startSystemServer`启动SystemServer进程

            a. 创建启动SystemServer参数数组，其中SystemServer进程的用户id和用户组id被设置为1000，且拥有1001~1010,1018、1021、1032、3001~3010的权限；进程名为`system_server`；启动类为`com.android.server.SystemServer`
            b. `Zygote.forkSystemServer`通过fork函数在当前进程创建一个子进程
            c. `handleSystemServerProcess`启动SystemServer进程

        * `runSelectLoop`等待客户端请求

    3. SystemServer进程

        接上文的`handleSystemServerProcess`

        * 关闭ServerSocket，由于fork自Zygote进程，而ServerSocket对于SystemServer无用，关闭之
        * 调用`RuntimeInit.zygoteInit`(`frameworks/base/core/java/com/android/internal/os/RuntimeInit.java`)
        * zygoteInit中调用`nativeZygoteInit`
        * 回调`AppRuntime`的`onZygoteInit`函数（`frameworks/base/cmds/app_process/app_main.cpp`）
        * `onZygoteInit`中启动一个Binder线程池，这样SystemServer进程就可以使用Binder来与其他进程通信了
        * zygoteInit中继续调用`applicationInit`（`frameworks/base/core/java/com/android/internal/os/RuntimeInit.java`）
        * `invokeStaticMain`动态调用`SystemServer.main`函数（`frameworks/base/services/java/com/android/server/SystemServer.java`）
        * `SystemServer.run`加载libandroid_servers.so，创建SystemServerManager（对系统服务进行创建、启动和生命周期管理）
        * `startBootstrapServices`（引导服务）用SystemServerManager启动了ActivityManagerService、PowerManagerServices、PackageManagerService等服务
        * `startCoreServices`（核心服务）启动了BatteryService、UsageStatsService和WebViewUpdateService等
        * `startOtherServices`（其他服务）启动CameraService、AlarmManagerService、VrManagerService等服务

    4. 启动Launcher

        ` <category android:name="android.intent.category.HOME" /> `

- [ ] Activity的启动流程
- [ ] Application的启动流程
- [ ] Android跨进程通信的方式
- [ ] IBinder机制
- [ ]  View的绘制流程
- [x]  LinearLayout和RelativeLayout性能比较

    它们之间的性能主要体现在measure上面。    

    * LinearLayout
        
        1. 在LinearLayout中不使用weight属性，将只进行一次measure过程
        2. 如果使用weight属性，将进行二次measure

    * RelativeLayout

        1. 横向和纵向分别进行一次排序测量
        2. measure优化失效问题

    RelativeLayout慢于LinearLayout是因为measure过程，但当LinearLayout有weight属性时候，两者差不多，都需要两次measure过程；RelativeLayout的子View如果高度和RelativeLayout不同，会引发效率问题，可以使用padding代替margin以优化此问题；在不影响层级深度的情况下，使用LinearLayout而不是RelativeLayout。

- [ ] WindowManager、Window、ViewRootImp、View的关系
- [ ] SurfaceView、TextureView和GLSurfaceView区别
- [ ] Surface和SurfaceTexture的原理
- [ ] Handler、MessageQueue和Message关系
- [x] 自定义View的几种方法

    * 自绘控件 CoinRainView
    * 组合控件 HotBurstLayout
    * 继承控件 CoverImageView

- [x] WindowManager创建悬浮框

    * 声明权限

        `<uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />`

    * 获取WindowManager服务

        ```
        //获取应用的Context
        mContext = context.getApplicationContext();
        //获取WindowManager
        mWindowManager = (WindowManager)mContext.getSystemService(Context.WINDOW_MANAGER);
        ```

    * 设置悬浮框参数

        ```
        final WindowManager.LayoutParams params = new WindowManager.LayoutParams();
        //类型,值越大越靠zOrder的top
        params.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT;
        //设置外部可获取焦点和接收触摸事件
        params.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
        //format，位图格式，默认为不透明
        params.format = PixelFormat.RGBA_8888;
        //位置相关参数
        params.x = 100;
        params.y = 100;
        params.width = 100;
        params.height = 100;
        params.gravity = Gravity.LEFT | Gravity.TOP;        
        ```

    * 设置输入事件
    * 添加、更新、删除

        ```
        //窗口添加View
        public void addView(View view,ViewGroup.LayoutParams params);
        //更新窗口中的View
        public void updateViewLayout(View view,ViewGroup.LayoutParams params);
        //在窗口中删除View
        public void removeView(View view);
        ```


- [x] ANR

    * 输入事件5s内没有被处理
    * BroadcastReceiver的onRecieve没能在规定时间处理完，前台广播是10s，后台是60s
    * 前台Service20s没能完成启动，后台Service没能在200s没能完成启动
    * ContentProvider没能在10s内发布成功

    trace文件存放路径为`/data/anr/traces.txt`

- [ ] Android Touch事件传递机制

二、进阶

- [ ] JNI
- [ ] Android底层库so的坑
- [ ] UI优化
- [ ] 内存与性能优化、内存泄露检查
- [ ] 常用的图片加载框架
- [ ] Universal-Image-Loader源码解析
- [ ] LruCache和LruDiskCache
- [ ]  APK加壳
- [ ] 热修复
- [ ] 插件化
- [ ] 打包、发布、渠道、签名
- [ ] MediaCodec录制和转码
- [ ] MediaPlayer的播放控制
- [ ] WebView与JavaScript交互以及安全问题
- [ ] 断点续传
- [ ] 分片上传
- [ ] Retrofit源码解析
- [ ] RxJava源码解析
- [ ] ButterKnife源码解析
- [ ] Dagger源码解析
- [ ] MVP、MVC、MVVM应用开发架构
- [ ] Android Clean Architecture
- [ ] Android Apk瘦身经验
- [ ] Dalvik和Art区别
- [ ] Parcelable大数据传递问题
- [ ] 多线程中的死锁
- [ ] SharePreference

三、 Java基础知识

- [ ] Java的特性——继承、多态和封装
- [ ] HashMap原理
- [ ] 排序算法
- [ ] 非递归实现快速排序
- [ ] 反转链表
- [ ] 查找算法
- [ ] 设计模式6大原则
- [ ] 知道的设计模式、以及应用的设计模式
- [ ] JVM内存管理
- [ ] Java的四个内存引用及其作用
- [ ] Java的垃圾回收算法、G1算法
- [ ] 回收机制
- [ ] Java反射
- [ ] Java类加载
- [ ] Java注解
- [ ] 多线程
- [ ] 加锁机制
- [ ] 常见数据结构
- [ ] 栈
- [ ] 队列
- [ ] 哈希表
- [ ] 堆
- [ ] 二叉树
- [ ] 红黑树

四、 网络知识

- [ ] 网络请求加密
- [ ] Http、TCP、IP、UDP
- [ ] 三次握手和四次挥手
- [ ] TCP的滑动窗口机制
- [ ] TCP的流量控制
- [ ] TCP的拥塞控制
- [ ] HTTP协议
- [ ] 常用的HTTP协议的METHOD
- [ ] HTTP协议中常用的Header字段
- [ ] Http和Https的区别

五、 加分项

- [ ] OpenGL知识
- [ ] MP4文件格式
- [ ] PCM音频数据格式
- [ ] YUV色彩空间
- [ ] AndroidMultiTheme主题框架
