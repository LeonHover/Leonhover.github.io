 ### Android面试知识点汇总

一、 基础

- [x] Android四大组件

    Android四大基本组件分别是Activity、Service服务、Content Provider内容提供者和BroadcastReciever广播接收器。

- [x] Activity的生命周期

    ```flow
    st=>start:Activity启动
    e=>end:Activity销毁
    onCreate=>operation:onCreate
    onStart=>operation:onStart
    onRestart=>operation:onRestart
    onResume=>operation:onResume
    onPause=>operation:onPause
    onStop=>operation:onStop
    onDestroy=>operation:onDestroy

    st->onCreate->onStart->onResume->onPause->onStop->onDestroy->e
    onStop->onRestart->onStart
    onPause->onResume

    ```

    1. onStart和onStop、onResume和onPause的区别？

        onStart和onStop表示Activity的可见状态，而onResume和onStop表示Activity是否是前台可交互的状态；

    2. A启动B，A的onPause和B的onResume哪个先执行？

        在新的Activity启动之前，栈顶的Activity要先onPause后，新的Activity才能启动。也就是A执行完onPause后再执行B的onCreate、onStart和onResume。所以这里注意不要在onPause中执行耗时的操作，影响界面切换速度。
    
    3. 异常生命周期调用——onSaveInstanceState和onRestoreInstanceState

        只有异常情况下才会调用这两个周期方法。onSaveInstanceState调用时机在onStop之前，与onPause没有时序关系。onRestoreInstanceState调用时机在onStart之后。

    4. Activity的生存优先级

        前台Activity正在交互，优先级最高；可见但非前台Activity，次之；后台Activity，不可见，优先级最低。


- [x] Activity的LaunchMode

    Activity的四种LaunchMode：    
    * standard   标准模式
    * singleTop  栈顶复用模式
    * singleTask   栈内复用模式具有cleanTop的效果 
    * singleInstance    加强型的singleTask，单例Activity只单独存在在一个任务栈中

    startActivityForResult的方式启动SingleTask或SingleInstance启动模式的Activity，onActivityResult会立即调用并返回REQUEST_CANCELED。

- [x] Intent和PendingIntent的区别

    a. Intent是立即使用，而PendingIntent有执行条件，还可以被cancel掉；
    b. Intent在程序结束后会终止，而PendingIntent不会，等待它自己的执行条件满足时候开始执行；
    c. PendingIntent自带Context，而Intent需要在某个Context内运行；
    d. Intent在原Task中运行，PendingIntent在新的Task中运行；

- [x] ContentProvider

    ContentProvider叫做内容提供者将特定的应用程序数据提供给其他的应用程序使用，数据可以是存储于文件系统、SQLite数据库或者其他方式。常见系统提供的ContentProvider有媒体、联系人、短信等。

    关键方法：
    ```
    //创建ContentProvider时候的调用
    public boolean onCreate();
    //查询
    public Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder);
    //插入数据到指定的Uri
    public Uri insert(Uri uri,ContentValues values);
    //从指定的Uri中删除数据
    public int delete(Uri uri,String selection,String[] selectionArgs);
    //更新Uri的Content Provider中的数据
    public int update(Uri uri,ContentValues values,String selection,String[] selectionArgs);
    //回去MIME数据类型
    public String getType(Uri uri);//vnd.android.cursor.dir/person——表示返回数据为person的集合。
    ```
    对ContentProvider的数据进行数据增删改查的时候，可以使用ContentResolver来完成。

    Uri,系统资源的唯一标识。

    `content://com.example.transportationprovider/trains/122`

    `content://`——标准前缀
    `com.example.transportationprovider`——Uri的标识，用于唯一标识这个ContentProvider，外部调用者可以用这个标识来找到这个Provider。
    `trains`——路径（Path），一般就是数据库中要操作的表的名称。
    `122`——数据ID。

    监听ContentProvider中的数据变化
    ```
    //注册回调
    getContentResolver().registerContentObserver(uri,new DataObserver());
    //notifyChange
    getContext().getContentResolver().notifyChange(uri,null);
    //onChange
    public class DataObserver extends ContentObserver {
        public void onChange(boolean selfChange) {
            //handle数据改变
        }
    }
    ```

- [x] BroadCastReceiver

    动态注册广播
    最好在Activity的onResume()注册、onPause()注销，因为异常退出的Activity可能会不执行onStop、onDestroy，造成内存泄露。
    广播也不能重复注册、重复注销。

    广播的类型主要分为5类：
    * 普通广播(Normal Broadcast)
        sendBroadcast(Intent);
    * 系统广播(System Broadcast)
    * 有序广播(Ordered Broadcast)
        有序针对广播的接收者而言的，发送出去的广播被接受者按照先后顺序接收。

        顺序规则：
        1. 按照Priority属性值从大到小排序；
        2. Priority属性相同的，动态注册广播优先;

        特点：
        1. 顺序接收
        2. 先接收的接收者可以对广播进行截断，后接收的广播接收者不再接收此广播；
        3. 先接收的接收者可以堆广播进行修改，后接收的广播接收者接收到的是被修改后的广播；

        sendOrderedBroadcast(Intent)

    * 粘性广播(Sticky Broadcast)
    * App应用内广播(Local Broadcast)

        面对两种问题：
        1. 其他应用针对性发出与当前应用IntentFilter匹配的广播，导致应用不断接收广播并处理；
        2. 其他应用注册与当前应用一致的IntentFilter用于接收广播，获取广播具体信息，造成安全性和效率性问题；

        解决方案：
        a. 将全局广播设置为局部广播
            * exported=false
            * 增设权限permission
            * 发送广播时设定接收者的所在的包名
                ```
                intent.setPackage(pkgName);
                ```
        b. 使用封装号的LocalBroadcastManager类
        
    **注意**

        对于不同注册方式的广播接收器回调onReceive(Context context,Intent intent)中Context返回值是不一样的：
        * 静态注册（全局或应用内广播），Context为ReceiverRestrictedContxt；
        * 全局广播的动态注册，Activity的Context；
        * 应用内动态注册（LocalBroadcastManager），Application的Context；
        * 应用内动态注册（非LocalBroadcastManager），Activity的Context；

- [x] Service

    Service称作后台服务，可以脱离UI来处理事务。Service运行与进程的主线程中，如果是UI进程的话，要注意耗时的操作会影响UI绘制，造成Anr。
    启动Service的方式：
    * startService
    * bindService

    销毁Service：
    * 仅startService启动的，stopService即可；
    * 仅bindService启动的，unbindService即可；
    * startService后，又bindService，需要stopService和unbindService后，才会销毁；    

- [x] IntentService

    IntentService Service和Handler的结合产物，IntentService持有一个HandlerThread，每次启动IntentService就会调用onStart，在onStart中提交一个Message到Handler中，去执行onHandleIntent。

- [x] Fragment的生命周期

    ```flow
    st=>start:Fragment is added
    e=>end:Fragment is destroyed
    onAttach=>operation:onAttach
    onCreate=>operation:onCreate
    onCreateView=>operation:onCreateView
    onActivityCreated=>operation:onActivityCreated
    onStart=>operation:onStart
    onResume=>operation:onResume
    onPause=>operation:onPause
    onStop=>operation:onStop
    onDestroyView=>operation:onDestroyView
    onDetach=>operation:onDetach
    st->onAttach->onCreate->onCreateView->onActivityCreated->onStart->onResume->onPause->onStop->onDestroyView->onDetach->e
    onDestroyView->onCreateView
    ```

- [ ] Android系统的启动流程
- [ ] Activity的启动流程
- [ ] Application的启动流程
- [ ] Android跨进程通信的方式
- [ ] IBinder机制
- [ ] Parcelable大数据传递问题
- [ ]  View的绘制流程
- [ ]  LinearLayout和RelativeLayout的区别
- [ ] WindowManager、Window、ViewRootImp、View的关系
- [ ] SurfaceView、TextureView和GLSurfaceView区别
- [ ] Surface和SurfaceTexture的原理
- [ ] Handler、MessageQueue和Message关系
- [ ] 自定义View的几种方法
- [ ] WindowManager创建悬浮框
- [ ] ANR发生的条件
- [ ] Android Touch事件传递机制

二、进阶

- [ ] JNI
- [ ] Android底层库so的坑
- [ ] UI优化
- [ ] 内存与性能优化、内存泄露检查
- [ ] 常用的图片加载框架
- [ ] Universal-Image-Loader源码解析
- [ ] LruCache和LruDiskCache
- [ ]  APK加壳
- [ ] 热修复
- [ ] 插件化
- [ ] 打包、发布、渠道、签名
- [ ] MediaCodec录制和转码
- [ ] MediaPlayer的播放控制
- [ ] WebView与JavaScript交互以及安全问题
- [ ] 断点续传
- [ ] 分片上传
- [ ] Retrofit源码解析
- [ ] RxJava源码解析
- [ ] ButterKnife源码解析
- [ ] Dagger源码解析
- [ ] MVP、MVC、MVVM应用开发架构
- [ ] Android Clean Architecture
- [ ] Android Apk瘦身经验
- [ ] Dalvik和Art区别

三、 Java基础知识

- [ ] Java的特性——继承、多态和封装
- [ ] HashMap原理
- [ ] 排序算法
- [ ] 非递归实现快速排序
- [ ] 反转链表
- [ ] 查找算法
- [ ] 设计模式6大原则
- [ ] 知道的设计模式、以及应用的设计模式
- [ ] JVM内存管理
- [ ] Java的四个内存引用及其作用
- [ ] Java的垃圾回收算法、G1算法
- [ ] 回收机制
- [ ] Java反射
- [ ] Java类加载
- [ ] Java注解
- [ ] 多线程
- [ ] 加锁机制
- [ ] 常见数据结构
- [ ] 栈
- [ ] 队列
- [ ] 哈希表
- [ ] 堆
- [ ] 二叉树
- [ ] 红黑树

四、 网络知识

- [ ] 网络请求加密
- [ ] Http、TCP、IP、UDP
- [ ] 三次握手和四次挥手
- [ ] TCP的滑动窗口机制
- [ ] TCP的流量控制
- [ ] TCP的拥塞控制
- [ ] HTTP协议
- [ ] 常用的HTTP协议的METHOD
- [ ] HTTP协议中常用的Header字段
- [ ] Http和Https的区别

五、 加分项

- [ ] OpenGL知识
- [ ] MP4文件格式
- [ ] PCM音频数据格式
- [ ] YUV色彩空间
- [ ] AndroidMultiTheme主题框架
