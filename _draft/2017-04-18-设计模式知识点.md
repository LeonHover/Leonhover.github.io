### 一、设计模式六大原则

    1. 单一职责原则(Single Responsibility Principle) 

        定义：应该有且仅有一个原因引起类的变更
        好处：
            * 降低了类的复杂性
            * 可读性高
            * 可维护性高
            * 变更引起的风险变低

    2. 里氏替换原则(Liskov Substitution Principle)

        Java的三大特征：继承、封装、多态

        面向对象语言的继承的优点：

            * 代码共享、减少创建类的工作
            * 提高代码重用性
            * 子类可以形似父类，又异于父类
            * 提高代码可扩展性
            * 提高产品或项目的开放性

        继承也有缺点：

            * 继承是入侵性的
            * 降低代码的灵活性
            * 增强了耦合性

        定义：只要父类出现的地方就可以用子类来代替，而不产生任何错误或异常，反之就不行了。
        这里包含了4层含义：

            * 子类必须完全实现父类的方法
            * 子类可以有自己的个性
            * 覆盖或实现父类的方法时输入参数可以被放大
            * 覆写或实现父类的方法时输出结果可以被缩小

    3. 依赖倒置原则(Dependence Inversion Principle)

        定义：高层模块不应该依赖底层模块，两者都应该依赖其抽象，抽象不应该依赖细节，细节应该依赖抽象。

        Java中抽象就是接口或抽象类，不能被直接实例化，细节就是实现类，实现接口或继承抽象类。

        依赖倒置原则在Java中的表现是：

            * 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的
            * 接口或抽象类不依赖于实现
            * 实现类依赖接口或抽象类
        
        采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。

    4. 接口隔离原则()

        定义：客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上。

        接口隔离原则的含义：

            * 接口要尽量小，但也要满足单一职责原则
            * 接口要高内聚
            * 定制服务
            * 接口设计是有限度的

    5. 迪米特法则(Law of Demeter)

        又被称作最少知识原则，定义：一个对象应该对其他对象有最少的了解，一个类应该对自己需要耦合或调用的类知道的最少。

        迪米特法则降低了类的耦合性，具体含义为：

            * 只和朋友交流
            * 朋友之间也是有距离的
            * 是自己的就是自己的
            * 谨慎使用Serializable

    6. 开闭原则()

        定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。

### 二、23种设计模式

    1. 单例模式

        定义：确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例

        单例模式的优点：

            * 减少了内存开销
            * 减少了系统的性能开销
            * 避免对资源的多重占用
            * 可以在系统设置全局访问点，优化和共享资源访问
        
        单例模式的缺点：

            * 单例模式一般没有接口，扩展很困难
            * 单例模式对测试不利
            * 单例模式与单一职责原则有冲突

        实现方法：

            * 饿汉模式
            * synchronized修饰懒汉模式
            * Double-Check
            * 静态内部类
            * Enum单例

    2. 工厂方法模式

        定义：定义一个用户创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。

        优点：

            * 良好的封装性，代码结构清晰，降低模块间的耦合
            * 有很强的扩展性
            * 屏蔽了产品类，调用者不用关心产品类如何变化，产品类的实例化工作都是工厂类负责
            * 典型的解耦框架

        工厂方法模式实现：

            * 简单工厂模式
            * 多工厂模式

    3. 抽象工厂模式

        定义：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。

        优点：

            * 封装性
            * 产品族内的约束为非公开状态
     
        缺点：

            * 产品族扩展非常困难

        应用场景：一个对象族（或是一组没有任何关系的对象）都有相同的约束，就可以使用抽象工厂模式。

    4. 模板方法

        定义：定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

        优点：

            * 封装不变部分，扩展可变部分
            * 提取公共部分代码，便于维护
            * 行为由父类控制，子类实现

        应用场景：

            * 多个子类有公有方法，并且逻辑基本相同时
            * 重要、复杂的算法，可以把核心算法设计为模板方法，周边细节功能由各个子类实现
            * 重构时，把相同的代码抽取到父类中，然后通过钩子函数约束其行为。

    5. 建造者模式

        定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建出不同的表示。

        优点：

            * 封装性
            * 建造者独立，容易扩展
            * 便于控制风险

        应用场景：

            * 相同方法、不同的执行顺序，产生不同的事件结果时，可以采用建造者模式
            * 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时
            * 在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到

    6. 代理模式

        定义：为其他对象提供一种代理以控制对这个对象的访问

        优点：

            * 职责清晰
            * 高扩展性
            * 智能化

        代理模式扩展有：普通代理，强制代理，虚拟代理，动态代理

    7. 原型模式

        定义：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

        优点：

            * 性能优良
            * 逃避构造函数的约束，这个既是优点又是缺点。

        应用场景：

            * 资源优化场景
            * 性能和安全要求的场景
            * 一个对象多个修改者的场景

        浅拷贝：clone的时候，只是拷贝本对象，其对象内部的数组、应用对象等都不拷贝，还是指向原生对象的内部元素地址，这种就是浅拷贝。反之为深拷贝。

    8. 中介者模式

        定义：用一个中介对象封装一系列的对象交互，中介者使各个对象不需要显式地相互作用，从而使其耦合松散，而且可以独立地改变他们之间的交互。

        优点：减少类间的依赖，把原有的一对多的依赖变为一对一的依赖，也降低了类间的耦合。

        缺点：中介者会膨胀的很大，而且逻辑复杂

        应用场景：在类图中出现了蜘蛛网状结构，可以使用中介者模式把蛛网树立为星型结构，使原本复杂的混乱的关系变得清晰简单。

    9. 命令模式

        定义：是一个高内聚的模式，其定义为将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。

        优点：

            * 类间解耦
            * 可扩展性

        缺点：命令模式的缺点是命令的子类个数可能会过多。