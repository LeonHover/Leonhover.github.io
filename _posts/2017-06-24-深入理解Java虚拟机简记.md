---
layout: post
title:  "深入理解Java虚拟机简记"
date:   2017-06-24
categories: 设计模式 阅读笔记
---

## 第一部分 走近Java
### 第1章 走近Java

## 第二部分 自动内存管理机制
### 第2章 Java内存区域与内存溢出异常
#### 1. 运行时数据区域
Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域：堆（Heap）、虚拟机栈（VM Stack）、本地方法栈（Native Method Stack）、方法区（Method Area）和程序计数器（Program Counter Register）。

1.1 程序计数器（Program Counter Register）

程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。

如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。

每条线程都有独立的程序计数器，互不影响。

此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

1.2 Java虚拟机栈（VM Stack）

Java虚拟机栈也是线程私有的，它的生命周期与线程相同。它描述的是Java方法执行的内存模型。方法运行时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息，方法的调用到执行结束对应的就是栈帧在Java虚拟机栈中入栈和出栈的过程。

经常有人将Java的内存区域分为堆内存（Heap）和栈内存（Stack）,其中的栈就是这里说的Java虚拟机栈或虚拟机栈中的局部变量表部分。局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型占用1个。

如果线程请求的栈深度大渔虚拟机允许的深度，将抛出StackOverFlowError异常；如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

1.3 本地方法栈（Native Method Stack）

本地方法栈与虚拟机栈的作用很相似，它们之间的区别不过是本地方法栈是为虚拟机使用的Native方法服务的。

与虚拟机栈一样，本地方法栈区域也会抛出StackOverFlowError和OutOfMemoryError异常。

1.4 Java堆（Heap）
Java堆（Java Heap）是Java虚拟机所有管理的内存中最大的一块。它被所有的线程共享，在虚拟机启动时创建。几乎所有的对象实例以及数组都要在堆上分配。

Java堆是垃圾收集器管理的主要区域。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；再细致一点的有Eden控件、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分为多个线程私有的分配缓冲区（Thread Local Allocation Buffer）。

如果在堆中没有内存完成实例分配，并且堆无法再扩展时，将会抛出OutOfMemoryError的异常。

1.5 方法区（Method Area）
方法区也是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

1.6 运行时常量池（Runtime Constant Pool）

运行时常量池是方法区的一部分。用于存放编译期生成的各种字面量和符号引用，这部分是在类加载后进入方法区的时存放到常量池的。

除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池。

运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，在运行时也可能将新的常量放入池中，常见的是String类的intern()方法。

当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

1.7 直接内存（Direct Memory）

在JDK1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Chanel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java队中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆中和Native堆中来回复制数据。

这里也会抛出OutOfMemory异常，因为申请的内存会受到其他因素影响，超过一定限制就会抛异常。

#### 2. 虚拟机对象探秘

2.1 对象的创建

* 确保常量池中存放的是已解释的类；
* 类加载检查通过后，虚拟机为新生对象分配内存，对象所需内存在类加载完后便可完全确定；
* 虚拟机将分配到的内存空间都初始化为零值；
* 虚拟机对对象进行必要的设置，这些信息存放在对象的对象头（Object Head）中，根据当前的运行状态的不同，对象头有不同的设置方式；
* 执行完new指令后，会接着执行<init>方法；

2.2 对象的内存布局

对象在内存中存储的布局可以分为3块区域：对象头（Object Head）、实例数据（Instance Data）和对齐填充（Padding）。

对象头包括两部分信息：第一部分用于存储对象自身的运行时数据（Mark Word）；另一部分就是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针确定对象是哪个类的实例。

实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。

对齐填充并不是必然存在的，没有别的含义，仅仅起着占位符的作用。它的存在是由于内存管理系统要求对象起始地址必须是8字节的整数倍，或者说对象的大小必须是8字节的整数倍。

2.3 对象的访问定位

适用对象，Java程序需要通过栈上的reference数据来操作堆上的具体对象。

目前主流的访问方式有使用句柄和直接指针两种：
* 句柄访问，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息。
* 直接指针访问，reference中存储的直接就是对象地址，Java堆对象的布局中放置访问类型数据的相关信息。

### 第3章 垃圾收集器与内存分配策略

内存区域中的程序计数器、虚拟机栈、本地方法栈随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊的执行着出栈和入栈操作，每个栈帧分配多少内存在类结构确定下来时就已知了。因此这几个区域的内存分配和回收都具备确定性。而Java堆和方法区的不一样，这部分得内存的分配和回收都是动态的，垃圾器所关注的就是这部分内存。

#### 1. 对象已死吗

第一件事就是确定哪些对象还“活着”，哪些已经“死去”（不可能再被任何途径使用的对象）。

1.1 引用计数算法

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。

Java虚拟机里面没有选用引用计数算法来管理内存，主要原因就是它很难解决对象的相互循环引用的问题。

1.2 可达性分析算法

Java是称通过可达性分析（Reachability Analysis）来判定对象是否存活的。

算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链（Reference Chain），当对象到GC Roots没有任何引用链相连，此对象就是不可用的。

Java中，可作为GC Roots对象的包括：
* 虚拟机栈（栈帧中的本地变量）中引用的对象；
* 方法区中类静态属性引用的对象；
* 方法区中常量引用的对象；
* 本地方方法栈中JNI引用的对象；

1.3 再谈引用

Java对引用的概念扩充为4种：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。

* 强引用——只要强引用存在，垃圾收集器永远不会回收掉被引用的对象。
* 软引用——有用但非必需的对象，在将要发生内存溢出时，会把这类对象列入回收范围内进行第二次回收。
* 弱引用——非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集器发生之前。
* 虚引用——为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

1.4 生存还是死亡

不可达的对象需要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。

当对象没有覆盖finalize()方法，或finalize()方法已经被虚拟机掉用过，虚拟机将这两种情况都视为“没有必要执行”。

如果对象被判定为有必要执行finalize()方法，这个对象将会放置在一个叫做F-Queue的队列中，稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。如果对象想要在finalize方法中拯救自己——只需在finalize方法中重新与引用链上的任何一个对象建立关联即可。

任何一个对象的finalize()方法都只会被系统自动调用一次。

1.5 回收方法区

永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。

废弃常量比较简单，而判定一个类是否是“无用的类”的条件则苛刻许多。它需要满足三个条件才能算作“无用的类”：
* 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
* 加载该类的ClassLoader已经被回收；
* 该类对应的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法。

满足上面3个条件仅仅是“可以”，而不是不使用了就必然会回收。

在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载功能，以保证永久代不会溢出。

#### 2. 垃圾收集算法

2.1 标记-清除算法（Mark-Sweep）

标记-清除算法是最基础的算法，分为两个阶段：“标记”和“清除”。

不足：效率问题；空间问题，标记清除会产生大量不连续的内存碎片。

2.2 复制算法（Copying）

将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这块内存用完了，就将还存活的对象复制到另一块上，然后再把已使用过的内存空间一次清理掉。

不足：内存缩小为原来的一半。在对象存活率较高时就要进行较多的复制操作，严重影响效率。

目前商业虚拟机都采用复制算法来回收新生代。将内存分为Eden空间和两块Survivor空间，他们的比例为8：1。这样可利用内存空间就为90%。

2.3 标记-整理算法（Mark-Compact）

标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行整理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

2.4 分代收集算法（Generational Collection）

根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代。新生代每次垃圾收集时都发现有大批对象死去，只有少量存活，就选用复制算法。而老年代中因为对象存活率搞、没有额外控件对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法。


（中间章节等待继续添加）

### 第7章 虚拟机类加载机制

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

#### 1. 类加载的时机

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）。

5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：
* 使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候（被final修饰、已在编译期把结果放入常量池的静态字段除外），以及调用一个类的静态方法的时候。
* 使用java.lang.Reflect包的方法对类进行反射调用的时候。
* 当初始化一个类的时，如果发现其父类还没有进行过初始化。
* 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类。
* 动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先触发其初始化。

#### 2. 类加载的过程

2.1 加载

“加载”是“类加载”（Class Loading）过程的一个阶段，虚拟机需要完成3件事情：
* 通过一个类的全限定名来获取定义此类的二进制字节流；
* 将这个字节流所代表的静态存储结果转化为方法区的运行时数据结构；
* 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。


2.2 验证

这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

验证阶段大致分为4个阶段的校验动作：文件格式验证、元数据验证、字节码验证、符号应用验证。

2.3 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。

2.4 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

2.5 初始化

类初始化阶段是类加载过程的最后一步，到了初始化阶段，，才真正开始执行类中定义的Java程序代码。

#### 3. 类加载器

3.1 类与类加载器

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每个类加载器，都拥有一个独立的类名称空间。

3.2 双亲委派模型

从Java虚拟机的角度来讲，只存在梁总不同的类加载器：启动类加载器（Bootstrap ClassLoader）和所有其他的类的加载器。

绝大部分Java程序都会使用3种系统提供的类加载器：
* 启动类加载器（Bootstrap ClassLoader）；
* 扩展类加载器（Extension ClassLoader）；
* 应用程序类加载器（Application ClassLoader）；

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（composition）关系来复用父加载器的代码。

3.3 破坏双亲委派类型

双亲委派模型的第一次“被破坏”发生在双亲委派模型出现之前。

第二次“被破坏”是这个模型自身的缺陷所导致的，基础类要调用回用户代码的情况，为了解决这样的问题，引入了线程上下文类加载器（Thread Context ClassLoader）。

第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里的“动态性”指的是：代码热替换（HotSwap）、模块热部署（Hot Deployment）等。

（中间章节等待更新）



## 第一部分 走近Java
### 第1章 走近Java

## 第二部分 自动内存管理机制
### 第2章 Java内存区域与内存溢出异常
#### 1. 运行时数据区域
Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域：堆（Heap）、虚拟机栈（VM Stack）、本地方法栈（Native Method Stack）、方法区（Method Area）和程序计数器（Program Counter Register）。

1.1 程序计数器（Program Counter Register）

程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。

如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。

每条线程都有独立的程序计数器，互不影响。

此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

1.2 Java虚拟机栈（VM Stack）

Java虚拟机栈也是线程私有的，它的生命周期与线程相同。它描述的是Java方法执行的内存模型。方法运行时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息，方法的调用到执行结束对应的就是栈帧在Java虚拟机栈中入栈和出栈的过程。

经常有人将Java的内存区域分为堆内存（Heap）和栈内存（Stack）,其中的栈就是这里说的Java虚拟机栈或虚拟机栈中的局部变量表部分。局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型占用1个。

如果线程请求的栈深度大渔虚拟机允许的深度，将抛出StackOverFlowError异常；如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

1.3 本地方法栈（Native Method Stack）

本地方法栈与虚拟机栈的作用很相似，它们之间的区别不过是本地方法栈是为虚拟机使用的Native方法服务的。

与虚拟机栈一样，本地方法栈区域也会抛出StackOverFlowError和OutOfMemoryError异常。

1.4 Java堆（Heap）
Java堆（Java Heap）是Java虚拟机所有管理的内存中最大的一块。它被所有的线程共享，在虚拟机启动时创建。几乎所有的对象实例以及数组都要在堆上分配。

Java堆是垃圾收集器管理的主要区域。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；再细致一点的有Eden控件、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分为多个线程私有的分配缓冲区（Thread Local Allocation Buffer）。

如果在堆中没有内存完成实例分配，并且堆无法再扩展时，将会抛出OutOfMemoryError的异常。

1.5 方法区（Method Area）
方法区也是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

1.6 运行时常量池（Runtime Constant Pool）

运行时常量池是方法区的一部分。用于存放编译期生成的各种字面量和符号引用，这部分是在类加载后进入方法区的时存放到常量池的。

除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池。

运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，在运行时也可能将新的常量放入池中，常见的是String类的intern()方法。

当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

1.7 直接内存（Direct Memory）

在JDK1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Chanel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java队中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆中和Native堆中来回复制数据。

这里也会抛出OutOfMemory异常，因为申请的内存会受到其他因素影响，超过一定限制就会抛异常。

#### 2. 虚拟机对象探秘

2.1 对象的创建

* 确保常量池中存放的是已解释的类；
* 类加载检查通过后，虚拟机为新生对象分配内存，对象所需内存在类加载完后便可完全确定；
* 虚拟机将分配到的内存空间都初始化为零值；
* 虚拟机对对象进行必要的设置，这些信息存放在对象的对象头（Object Head）中，根据当前的运行状态的不同，对象头有不同的设置方式；
* 执行完new指令后，会接着执行<init>方法；

2.2 对象的内存布局

对象在内存中存储的布局可以分为3块区域：对象头（Object Head）、实例数据（Instance Data）和对齐填充（Padding）。

对象头包括两部分信息：第一部分用于存储对象自身的运行时数据（Mark Word）；另一部分就是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针确定对象是哪个类的实例。

实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。

对齐填充并不是必然存在的，没有别的含义，仅仅起着占位符的作用。它的存在是由于内存管理系统要求对象起始地址必须是8字节的整数倍，或者说对象的大小必须是8字节的整数倍。

2.3 对象的访问定位

适用对象，Java程序需要通过栈上的reference数据来操作堆上的具体对象。

目前主流的访问方式有使用句柄和直接指针两种：
* 句柄访问，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息。
* 直接指针访问，reference中存储的直接就是对象地址，Java堆对象的布局中放置访问类型数据的相关信息。

### 第3章 垃圾收集器与内存分配策略

内存区域中的程序计数器、虚拟机栈、本地方法栈随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊的执行着出栈和入栈操作，每个栈帧分配多少内存在类结构确定下来时就已知了。因此这几个区域的内存分配和回收都具备确定性。而Java堆和方法区的不一样，这部分得内存的分配和回收都是动态的，垃圾器所关注的就是这部分内存。

#### 1. 对象已死吗

第一件事就是确定哪些对象还“活着”，哪些已经“死去”（不可能再被任何途径使用的对象）。

1.1 引用计数算法

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。

Java虚拟机里面没有选用引用计数算法来管理内存，主要原因就是它很难解决对象的相互循环引用的问题。

1.2 可达性分析算法

Java是称通过可达性分析（Reachability Analysis）来判定对象是否存活的。

算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链（Reference Chain），当对象到GC Roots没有任何引用链相连，此对象就是不可用的。

Java中，可作为GC Roots对象的包括：
* 虚拟机栈（栈帧中的本地变量）中引用的对象；
* 方法区中类静态属性引用的对象；
* 方法区中常量引用的对象；
* 本地方方法栈中JNI引用的对象；

1.3 再谈引用

Java对引用的概念扩充为4种：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。

* 强引用——只要强引用存在，垃圾收集器永远不会回收掉被引用的对象。
* 软引用——有用但非必需的对象，在将要发生内存溢出时，会把这类对象列入回收范围内进行第二次回收。
* 弱引用——非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集器发生之前。
* 虚引用——为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

1.4 生存还是死亡

不可达的对象需要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。

当对象没有覆盖finalize()方法，或finalize()方法已经被虚拟机掉用过，虚拟机将这两种情况都视为“没有必要执行”。

如果对象被判定为有必要执行finalize()方法，这个对象将会放置在一个叫做F-Queue的队列中，稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。如果对象想要在finalize方法中拯救自己——只需在finalize方法中重新与引用链上的任何一个对象建立关联即可。

任何一个对象的finalize()方法都只会被系统自动调用一次。

1.5 回收方法区

永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。

废弃常量比较简单，而判定一个类是否是“无用的类”的条件则苛刻许多。它需要满足三个条件才能算作“无用的类”：
* 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
* 加载该类的ClassLoader已经被回收；
* 该类对应的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法。

满足上面3个条件仅仅是“可以”，而不是不使用了就必然会回收。

在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载功能，以保证永久代不会溢出。

#### 2. 垃圾收集算法

2.1 标记-清除算法（Mark-Sweep）

标记-清除算法是最基础的算法，分为两个阶段：“标记”和“清除”。

不足：效率问题；空间问题，标记清除会产生大量不连续的内存碎片。

2.2 复制算法（Copying）

将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这块内存用完了，就将还存活的对象复制到另一块上，然后再把已使用过的内存空间一次清理掉。

不足：内存缩小为原来的一半。在对象存活率较高时就要进行较多的复制操作，严重影响效率。

目前商业虚拟机都采用复制算法来回收新生代。将内存分为Eden空间和两块Survivor空间，他们的比例为8：1。这样可利用内存空间就为90%。

2.3 标记-整理算法（Mark-Compact）

标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行整理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

2.4 分代收集算法（Generational Collection）

根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代。新生代每次垃圾收集时都发现有大批对象死去，只有少量存活，就选用复制算法。而老年代中因为对象存活率搞、没有额外控件对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法。


（中间章节等待继续添加）

### 第7章 虚拟机类加载机制

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

#### 1. 类加载的时机

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）。

5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：
* 使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候（被final修饰、已在编译期把结果放入常量池的静态字段除外），以及调用一个类的静态方法的时候。
* 使用java.lang.Reflect包的方法对类进行反射调用的时候。
* 当初始化一个类的时，如果发现其父类还没有进行过初始化。
* 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类。
* 动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先触发其初始化。

#### 2. 类加载的过程

2.1 加载

“加载”是“类加载”（Class Loading）过程的一个阶段，虚拟机需要完成3件事情：
* 通过一个类的全限定名来获取定义此类的二进制字节流；
* 将这个字节流所代表的静态存储结果转化为方法区的运行时数据结构；
* 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。


2.2 验证

这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

验证阶段大致分为4个阶段的校验动作：文件格式验证、元数据验证、字节码验证、符号应用验证。

2.3 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。

2.4 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

2.5 初始化

类初始化阶段是类加载过程的最后一步，到了初始化阶段，，才真正开始执行类中定义的Java程序代码。

#### 3. 类加载器

3.1 类与类加载器

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每个类加载器，都拥有一个独立的类名称空间。

3.2 双亲委派模型

从Java虚拟机的角度来讲，只存在梁总不同的类加载器：启动类加载器（Bootstrap ClassLoader）和所有其他的类的加载器。

绝大部分Java程序都会使用3种系统提供的类加载器：
* 启动类加载器（Bootstrap ClassLoader）；
* 扩展类加载器（Extension ClassLoader）；
* 应用程序类加载器（Application ClassLoader）；

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（composition）关系来复用父加载器的代码。

3.3 破坏双亲委派类型

双亲委派模型的第一次“被破坏”发生在双亲委派模型出现之前。

第二次“被破坏”是这个模型自身的缺陷所导致的，基础类要调用回用户代码的情况，为了解决这样的问题，引入了线程上下文类加载器（Thread Context ClassLoader）。

第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里的“动态性”指的是：代码热替换（HotSwap）、模块热部署（Hot Deployment）等。

（中间章节等待更新）



